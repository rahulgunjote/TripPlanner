default_platform(:ios)

platform :ios do
  # Variables
  SCHEME = "TripPlanner"
  PROJECT = "TripPlanner.xcodeproj"
  
  # Detect CI environment
  IS_CI = ENV['CI'] == 'true' || ENV['GITHUB_ACTIONS'] == 'true'
  
  # Configuration based on environment
  if IS_CI
    # CI Environment (GitHub Actions)
    SIMULATOR = "iPhone 16"
    IOS_VERSION = "18.0"  # Xcode 16.4 supports up to iOS 18.5.99
    XCODE_VERSION = "16.4"
  else
    # Local Development Environment
    SIMULATOR = "iPhone 17"
    IOS_VERSION = "26.0"
    XCODE_VERSION = nil # Skip Xcode version check locally
  end
  
  before_all do
    if IS_CI
      UI.important("ü§ñ Running in CI environment")
      UI.message("Simulator: #{SIMULATOR}")
      UI.message("iOS Version: #{IOS_VERSION}")
      ensure_xcode_version(version: XCODE_VERSION)
    else
      UI.important("üíª Running in local environment")
      UI.message("Simulator: #{SIMULATOR}")
      UI.message("iOS Version: #{IOS_VERSION}")
    end
  end

  desc "Build the project"
  lane :build do
    UI.message("üî® Building TripPlanner...")
    
    destination = "platform=iOS Simulator,name=#{SIMULATOR},OS=#{IOS_VERSION}"
    UI.message("Building for destination: #{destination}")
    
    xcodebuild(
      scheme: SCHEME,
      project: PROJECT,
      configuration: "Debug",
      destination: destination,
      clean: true,
      build: true,
      xcargs: "-quiet"
    )
    
    UI.success("‚úÖ Build completed successfully!")
  end

  desc "Run all tests (Unit + UI)"
  lane :test do
    UI.message("üß™ Running all tests...")
    
    destination = "platform=iOS Simulator,name=#{SIMULATOR},OS=#{IOS_VERSION}"
    UI.message("Testing on destination: #{destination}")
    
    scan(
      scheme: SCHEME,
      project: PROJECT,
      destination: destination,
      clean: true,
      code_coverage: true,
      output_directory: "./fastlane/test_output",
      output_types: "html,junit",
      fail_build: true,
      reset_simulator: true
    )
    
    UI.success("‚úÖ All tests passed!")
  end

  desc "Run unit tests only"
  lane :unit_tests do
    UI.message("üß™ Running unit tests...")
    
    destination = "platform=iOS Simulator,name=#{SIMULATOR},OS=#{IOS_VERSION}"
    UI.message("Testing on destination: #{destination}")
    
    scan(
      scheme: SCHEME,
      project: PROJECT,
      destination: destination,
      clean: true,
      code_coverage: true,
      only_testing: ["TripPlannerTests"],
      output_directory: "./fastlane/test_output/unit_tests",
      output_types: "html,junit",
      fail_build: true,
      reset_simulator: true
    )
    
    UI.success("‚úÖ Unit tests passed!")
  end

  desc "Run UI tests only"
  lane :ui_tests do
    UI.message("üß™ Running UI tests...")
    
    destination = "platform=iOS Simulator,name=#{SIMULATOR},OS=#{IOS_VERSION}"
    UI.message("Testing on destination: #{destination}")
    
    scan(
      scheme: SCHEME,
      project: PROJECT,
      destination: destination,
      clean: true,
      code_coverage: true,
      only_testing: ["TripPlannerUITests"],
      output_directory: "./fastlane/test_output/ui_tests",
      output_types: "html,junit",
      fail_build: true,
      reset_simulator: true
    )
    
    UI.success("‚úÖ UI tests passed!")
  end

  desc "Build for testing (used in CI)"
  lane :build_for_testing do
    UI.message("üî® Building for testing...")
    
    destination = "platform=iOS Simulator,name=#{SIMULATOR},OS=#{IOS_VERSION}"
    UI.message("Building for destination: #{destination}")
    
    xcodebuild(
      scheme: SCHEME,
      project: PROJECT,
      configuration: "Debug",
      destination: destination,
      build_for_testing: true,
      xcargs: "-quiet"
    )
    
    UI.success("‚úÖ Build for testing completed!")
  end

  desc "Run tests without building (used in CI)"
  lane :test_without_building do |options|
    UI.message("üß™ Running tests without building...")
    
    test_target = options[:target] || nil
    destination = "platform=iOS Simulator,name=#{SIMULATOR},OS=#{IOS_VERSION}"
    UI.message("Testing on destination: #{destination}")
    
    scan_options = {
      scheme: SCHEME,
      project: PROJECT,
      destination: destination,
      code_coverage: true,
      test_without_building: true,
      output_directory: "./fastlane/test_output",
      output_types: "html,junit",
      fail_build: true,
      reset_simulator: true
    }
    
    if test_target
      scan_options[:only_testing] = [test_target]
    end
    
    scan(scan_options)
    
    UI.success("‚úÖ Tests passed!")
  end

  desc "Generate code coverage report"
  lane :coverage do
    UI.message("üìä Generating code coverage report...")
    
    xcov(
      scheme: SCHEME,
      project: PROJECT,
      output_directory: "./fastlane/test_output/coverage",
      minimum_coverage_percentage: 60.0,
      ignore_file_path: "./.xcovignore"
    )
    
    UI.success("‚úÖ Coverage report generated!")
  end

  desc "Lint Swift code"
  lane :lint do
    UI.message("üîç Linting Swift code...")
    
    # Note: Requires SwiftLint to be installed
    # Install with: brew install swiftlint
    swiftlint(
      mode: :lint,
      config_file: ".swiftlint.yml",
      reporter: "html",
      output_file: "./fastlane/test_output/swiftlint.html",
      ignore_exit_status: false
    )
    
    UI.success("‚úÖ Linting completed!")
  end

  desc "Run full CI pipeline"
  lane :ci do
    UI.message("üöÄ Running full CI pipeline...")
    
    build
    unit_tests
    ui_tests
    
    UI.success("‚úÖ CI pipeline completed successfully!")
  end
  
  # MARK: - Launchable Integration
  
  desc "Record build for Launchable"
  lane :launchable_record_build do
    UI.message("üìù Recording build with Launchable...")
    
    sh("launchable record build --name '#{ENV['GITHUB_RUN_ID'] || Time.now.to_i}'")
    
    UI.success("‚úÖ Build recorded!")
  end
  
  desc "Run tests with Launchable subset"
  lane :launchable_subset_test do
    UI.header("üß† Running Launchable Intelligent Test Selection")
    
    # Record session start
    session_id = sh("launchable record session --build '#{ENV['GITHUB_RUN_ID'] || Time.now.to_i}'", log: false).strip
    ENV['LAUNCHABLE_SESSION_ID'] = session_id
    UI.message("Session ID: #{session_id}")
    
    # Record tests (discover all tests)
    UI.message("üîç Recording available tests...")
    sh("launchable record tests --session #{session_id} xcode")
    
    # Get subset of tests to run
    UI.message("üéØ Getting optimized test subset...")
    subset_file = ".launchable_subset.txt"
    sh("launchable subset --target 3m --session #{session_id} xcode > #{subset_file}")
    
    # Read subset tests
    subset_tests = File.read(subset_file).split("\n").reject(&:empty?)
    UI.message("üìä Running #{subset_tests.count} tests from subset")
    
    if subset_tests.empty?
      UI.important("‚ö†Ô∏è No tests in subset, running all tests")
      test
    else
      # Run subset tests
      destination = "platform=iOS Simulator,name=#{SIMULATOR},OS=#{IOS_VERSION}"
      
      scan(
        scheme: SCHEME,
        project: PROJECT,
        destination: destination,
        only_testing: subset_tests,
        code_coverage: true,
        output_directory: "./fastlane/test_output",
        output_types: "html,junit",
        fail_build: true,
        reset_simulator: true
      )
    end
    
    # Record test results
    UI.message("üì§ Uploading test results to Launchable...")
    sh("launchable record tests --session #{session_id} xcode ./fastlane/test_output/*.junit")
    
    UI.success("‚úÖ Launchable testing completed!")
  end
  
  desc "Run tests with Launchable (with fallback)"
  lane :launchable_test do
    begin
      launchable_subset_test
    rescue => e
      UI.error("‚ùå Launchable test failed: #{e.message}")
      UI.important("‚ö†Ô∏è Falling back to full test suite...")
      test
    end
  end
  
  desc "Verify Launchable setup"
  lane :launchable_verify do
    UI.header("üîç Verifying Launchable Setup")
    
    # Check if launchable is installed
    begin
      version = sh("launchable --version", log: false).strip
      UI.success("‚úÖ Launchable installed: #{version}")
    rescue
      UI.error("‚ùå Launchable not installed")
      UI.message("Install with: pip install launchable")
      return
    end
    
    # Check if token is set
    if ENV['LAUNCHABLE_TOKEN'].nil? || ENV['LAUNCHABLE_TOKEN'].empty?
      UI.error("‚ùå LAUNCHABLE_TOKEN not set")
      UI.message("Set with: export LAUNCHABLE_TOKEN=your_token")
    else
      UI.success("‚úÖ LAUNCHABLE_TOKEN is set")
    end
    
    # Verify organization
    begin
      sh("launchable verify")
      UI.success("‚úÖ Launchable authentication successful")
    rescue
      UI.error("‚ùå Launchable authentication failed")
    end
    
    UI.success("‚úÖ Launchable verification complete!")
  end

  desc "Clean build artifacts"
  lane :clean do
    UI.message("üßπ Cleaning build artifacts...")
    
    clear_derived_data
    
    UI.success("‚úÖ Cleanup completed!")
  end

  # Error handling
  error do |lane, exception|
    UI.error("‚ùå Lane #{lane} failed with error: #{exception.message}")
  end
end

